#!/bin/bash

##
##  Introduction:
##    My prefered SHELL is ksh, as we have had a long and illustrious
##    career together; however I have used BASH here to keep things
##    simpler for this example project.
##
##     I.E. show my scripting skills using a shell that should be
##          on any linux system in existance by default.
##
##    If I were writting an applicaton I would use Perl OR Java.
##

##
##  NOTES: This script was written for and tested on a VM installed
##         with a default CentOS 6.4; it should work equally well on
##         physical hardware running the same release. I fully
##         expect it will run on Red-Hat as well as earlier versions.
##
##          I.E. It should work on 4.x-6.x
##
##         This script is not comprehensive or production ready. It
##         makes too many assumptions and provide not options or
##         flexibility for alternatives. It simply shows one simple way
##         to build a PXE boot server.
##
##  ASSUMPTIONS:
##   1) The system we will demo PXE on is networked (kind of the point)
##   2) The PXE system has internet access to allow package installaton
##   3) has standard DHCP services from a local router [ home OR office etc ]
##      ( we don't need fixed IP's for this)
##   4) other system(s) with PXE client enabled NIC's are available
##      (we need the server and at least one client)
##

## Define few Functions

isNicUP()
{
  /sbin/ifconfig ${1-eth0} > /dev/null 2>&1
  return $?
}

getNicIP()
{
  echo $( /sbin/ifconfig ${1-eth0}|grep 'inet addr:'|awk '{print $2}'|awk -F: '{print $2}' )
}

getNicBcst()
{
  echo $( /sbin/ifconfig ${1-eth0}|grep 'inet addr:'|awk '{print $3}'|awk -F: '{print $2}' )
}

getNicMask()
{
  echo $( /sbin/ifconfig ${1-eth0}|grep 'inet addr:'|awk '{print $4}'|awk -F: '{print $2}' )
}

isNicIPed()
{
  IP=$(getNicIP ${1-eth0})
  [ '' != "$IP" ]
  return $?
}

hasNicConfig()
{
  if [ -f /etc/centos-release -o -f /etc/redhat-release ]
  then
    [ -d /etc/sysconfig/network-scripts/ -a -e /etc/sysconfig/network-scripts/ifcfg-$1 ]
    return $?
  fi

  if [ -f /etc/lsb-release -a -f /etc/network/interfaces ]
  then
    #-- YUCK! - not reliable
    # grep -q "$NIC" /etc/network/interfaces

    #-- config may be "unseen" OR "subtle"
    #-- (bad: assume if it's up life is good)
    isNicUP $1 && isNicIPed $1 && return $?
  fi

  return $?
}

isNicEnabled()
{
  [ -d /etc/sysconfig/network-scripts/ -a -e /etc/sysconfig/network-scripts/ifcfg-$1 ] && \
  grep -i '^ONBOOT=yes' /etc/sysconfig/network-scripts/ifcfg-$1 > /dev/null 2>&1
  return $?
}

enableNic()
{
  [ -d /etc/sysconfig/network-scripts/ -a -e /etc/sysconfig/network-scripts/ifcfg-$1 ] && \
  {
    cat /etc/sysconfig/network-scripts/ifcfg-$1 | \
    sed 's/ONBOOT=no/ONBOOT=yes/' > /tmp/ifcfg-$1
    cat /tmp/ifcfg-$1 > /etc/sysconfig/network-scripts/ifcfg-$1
    rm -f /tmp/ifcfg-$1
  }
}

TurnUpNIC()
{
  #-- Selected NIC
  NIC=${1-eth0}

  hasNicConfig $NIC || return $?
  isNicEnabled $NIC || enableNic $NIC
  isNicUP      $NIC && isNicIPed $nic && \
  {
    showMessage "Networking Status $NIC"
    showStatus $?
    return $?
  }

  ifup $NIC
}

showMessage() { printf "  %-32s : " "$1"; }
showStatus()
{
  STA=$1 # Status
  NOT=$2 # Note

# printf "  %-32s : " "$MSG"
  [ $STA -eq 0 ] && ST=OK || ST=FAIL
  [ '' == "$NOT" ] && echo $ST
  [ '' == "$NOT" ] || printf "%-4s [ %s ]\n" $ST "$NOT"

  return $STA
}

processAction()
{
  MSG=$1
  CMD=$2
  LOG=$3

  STATUS=0
  
  showMessage "$MSG"
  $CMD >> ${LOG}.$$ 2>&1
  STATUS=$?
  showStatus $STATUS "check: ${LOG}.$$"

  return $STATUS
}


##
## Announce our title & locate a package installer
##

echo
echo '  PXE Environment Setup Tool'
echo '   ( an automation demonstration script )'
echo

showMessage 'Pruned Logs from Prior runs'
/bin/rm -f /tmp/pxe-*.log.[0-9]*
showStatus 0 || exit $?

INSTALLER=

[ -x /usr/bin/yum     ] && INSTALLER='/usr/bin/yum     --assumeyes  install'
[ -x /usr/bin/apt-get ] && INSTALLER='/usr/bin/apt-get --assume-yes install'

[ '' == "$INSTALLER" ] && iFound=1 || iFound=0

showMessage 'Locate package installer'
showStatus $iFound "$INSTALLER" || exit $?


##
##  The Steps we (AKA: YOU) need to take to bring PXE booting to life.
##
##   1) Build a system/VM using a Linux Distro that this
##      script supports; you must do this yourself and download
##      this script to it. (I used CentOS "minimal-server")
##
##   2) My NIC was configured but not enabled to be turned on
##      at boot. I suspect a hold-over from a desktop setup where
##      some service allows the user to control it. All very ugly.
##      Lets make sure we're connected to the network or there is
##      little else we can do!
##


#-- First NIC UP wins!
for NIC in eth0 eth1 eth2 eth3
do
  TurnUpNIC $NIC && break
done


##
##   3) Install the xinetd and tftpd services and get them up and running
##

#-- Install tftpd and dependencies
# RH/CentOS == tftp-server
# Ubuntu    == tftpd
msg='Installing TFTPD & XINETD Svcs'
pkg='tftpd'
[ -f /etc/centos-release -o -f /etc/redhat-release ] && pkg='tftp-server'
log=/tmp/pxe-tftpd-server-install.log

# processAction "$msg" "$INSTALLER $pkg" $log || exit $?


#-- Provide a /etc/xinetd.d/tftp
##  (if not included in package YUCK!)
if [ -d /etc/xinetd.d -a ! -f /etc/xinetd.d/tftp ]
then
  showMessage 'Install /etc/xinetd.d/tftp'
  cat > /etc/xinetd.d/tftp <<!TFTP
# Installed by $0
service tftp
{
	protocol        = udp
	port            = 69
	socket_type     = dgram
	wait            = yes
	user            = nobody
	server          = /usr/sbin/in.tftpd
	server_args     = -s /var/lib/tftpboot
	disable         = no
}

# END
!TFTP

  [ -f /etc/xinetd.d/tftp ] && chmod 0644 /etc/xinetd.d/tftp

  showStatus $? || exit $?
else
  showMessage 'Install /etc/xinetd.d/tftp'
  showStatus 0 'Preexists' || exit $?
fi


#-- Build empty /var/lib/tftpboot
##  (if not included in package YUCK!)
if [ -d /var/lib/tftpboot ]
then
  showMessage 'Create /var/lib/tftpboot'
  showStatus 0 'Preexists' || exit $?
else
  CMD=/tmp/pxe-create-tftpboot-dir.bash
  LOG=/tmp/pxe-create-tftpboot-dir.log
  cat > $CMD <<!MKDIR
#!/bin/bash
    mkdir -p     /var/lib/tftpboot
    chmod 0755   /var/lib/tftpboot
    chown nobody /var/lib/tftpboot
!MKDIR
  chmod 0755 $CMD
  processAction 'Create /var/lib/tftpboot' $CMD $LOG || exit $?
fi

#-- Enable tftpd
msg='Enabling TFTPD'
log=/tmp/pxe-tftpd-server-enable.log

if [ -x /sbin/chkconfig ]
then
  processAction "$msg" "/sbin/chkconfig tftp" $log || exit $?
else
  showMessage "$msg"
  showStatus 0 'Assumed' || exit $?
fi

#-- Restart xinetd
processAction "Start/Restart XINTD" "service xinetd restart" /tmp/pxe-xinetd-service.log || exit $?


#-- Configure firewall (CentOS & RH)
if [ -f /etc/centos-release -o -f /etc/redhat-release ]
then
  msg='Add iptables rule for tftpd'
  showMessage "$msg"
  /sbin/iptables --list --line-numbers | grep -q tftp || \
  /sbin/iptables --insert INPUT 5 -m state --state NEW --proto udp --dport 69 -j ACCEPT > \
      /tmp/pxe-iptables.log.$$ 2>&1
  showStatus 0 "check: /tmp/pxe-iptables.log.$$" || exit $?

  msg='Save iptabels rules'
  showMessage "$msg"
  /sbin/iptables-save > /etc/sysconfig/iptables 2>> /tmp/iptables.log.$$
  showStatus 0 "check: /tmp/pxe-iptables.log.$$" || exit $?
fi


##
##   4) Install syslinux; it includes the binares to build PXE boot-chains
##      And populate tftpboot with these binaries and our example menus
##

#-- Install syslinux and dependencies
# RH/CentOS == syslinux
# Ubuntu    == syslinux
msg='Installing SYSLINUX software'
pkg='syslinux'
log=/tmp/pxe-syslinux-install.log

processAction "$msg" "$INSTALLER $pkg" $log || exit $?


#-- Prepare the /var/lib/tftpboot/ dir for usage
##   (populate it!)
ST=OK
(
  TFTPBOOTTGT=/var/lib/tftpboot
  [ -d $TFTPBOOTTGT ] || { echo 'Failed to find tftpboot dir'; exit 1; }

  cd $TFTPBOOTTGT || exit 1

  showMessage 'Populating tftpboot PXE menus'
  (
    cat <<!EOF
help/version.txt
help/help.txt
pxelinux.cfg/default
pxelinux.cfg/open-suse
pxelinux.cfg/open-suse.jpg
pxelinux.cfg/red-hat
pxelinux.cfg/red-hat.jpg
pxelinux.cfg/ubuntu
pxelinux.cfg/cent-os.jpg
pxelinux.cfg/windows.jpg
pxelinux.cfg/tools.jpg
pxelinux.cfg/cent-os
pxelinux.cfg/windows
pxelinux.cfg/tools
pxelinux.cfg/default.jpg
pxelinux.cfg/ubuntu.jpg
images/floppy-dos.imz
images/memtest86+-5.01.iso.gz
images/floppy-grub.imz
!EOF
  ) | \
  while read item
  do
    DIR=$( dirname $item )
    FIL=$( basename $item )
    [ -d $DIR ] || mkdir -p $DIR
    (
      cd $DIR || exit 1
      [ -f $FIL ] || \
      wget https://raw.githubusercontent.com/ancientwizard/pxe-setup-tool/master/tftpboot/${item}
    )
  done > /tmp/pxe-populate-tftpboot.log.$$ 2>&1

  showStatus $? "check: /tmp/pxe-populate-tftpboot.log.$$" || exit $?


  cd $TFTPBOOTTGT || exit 1
  ST='OK  '
  showMessage 'Populating tftpboot binaries'
  (
    [ -f pxelinux.0   ] || { ln $( echo /usr/*/syslinux/pxelinux.0   ) || ST=FAIL; }
    [ -d bin ] || mkdir bin
    cd bin || ST=FAIL
    [ -f menu.c32     ] || { ln $( echo /usr/*/syslinux/menu.c32     ) || ST=FAIL; }
    [ -f vesamenu.c32 ] || { ln $( echo /usr/*/syslinux/vesamenu.c32 ) || ST=FAIL; }
    [ -f memdisk      ] || { ln $( echo /usr/*/syslinux/memdisk      ) || ST=FAIL; }
  ) >> /tmp/pxe-populate-tftpboot.log.$$ 2>&1
  echo "$ST [ check: /tmp/pxe-populate-tftpboot.log.$$ ]"
)


##
##   6) Install, configure and start the DHCP service
##      We need this to tell the PXE booting system what to do
##      (I.E. here is you IP sir, go and get this file ... )
##
##   BUGS: I assume the subnet is at least a class "C" in size!
##         (anything smaller and the computed range may be wrong)
##

# VICB
#-- Install dhcpd and dependencies
# RH/CentOS == dhcp
# Ubuntu    == udhcpd
msg='Installing DHCPD server'
pkg='udhcpd'
[ -f /etc/centos-release -o -f /etc/redhat-release ] && pkg='dhcp'
#echo we continue


#exit 0


if [ -f /etc/centos-release -o -f /etc/redhat-release ]
then
  ST=OK

  echo -n "  Installing DHCP server         : "
  /usr/bin/yum --assumeyes install dhcp    > /tmp/dhcpd-install.log 2>&1
  [ $? -eq 0 ] && ST='OK  ' || ST=FAIL
  echo "$ST [ check: /tmp/dhcpd-install.log ]"

# iptables --verbose --insert INPUT 5 -m state --state NEW --proto udp --dport 67 -j ACCEPT
#  (i did not have to do this for DHCP, initial packets are bcast/discovery and make it through;
#   my best guess)
fi


#-- Compute Network values from the "UP" NIC
##   use them to build a simple dhcpd.conf file.

echo -n "  Building dhcpd.conf file       : "

NIC_ADDR=$(getNicIP   $NIC)
NIC_MASK=$(getNicMask $NIC)
NIC_BCST=$(getNicBcst $NIC)

declare -a ADDR=( $(echo $NIC_ADDR|sed 's/[.]/ /g') )
declare -a MASK=( $(echo $NIC_MASK|sed 's/[.]/ /g') )
declare -a BCST=( $(echo $NIC_BCST|sed 's/[.]/ /g') )

NIC_NET="$(( ${ADDR[0]} & ${MASK[0]} )).$(( ${ADDR[1]} & ${MASK[1]} ))"
NIC_NET="${NIC_NET}.$(( ${ADDR[2]} & ${MASK[2]} ))"
NIC_NET="${NIC_NET}.$(( ${ADDR[3]} & ${MASK[3]} ))"

NIC_NST="$(( ${ADDR[0]} & ${MASK[0]} )).$(( ${ADDR[1]} & ${MASK[1]} ))"
NIC_NST="${NIC_NST}.$(( ${ADDR[2]} & ${MASK[2]} ))"
NIC_NST="${NIC_NST}.$(( ( ${ADDR[3]} & ${MASK[3]} ) + 1 ))"

NIC_NED="${BCST[0]}.${BCST[1]}.${BCST[2]}.$(( ${BCST[3]} - 1 ))"

NIC_RNG="${BCST[0]}.${BCST[1]}.${BCST[2]}.240"

NIC_RTR=$( netstat -rn|grep $NIC|grep '^0.0.0.0'|awk '{print $2}' )

# echo "  Using $NIC for DHCP setup: $NIC_ADDR $NIC_MASK $NIC_NET"
# echo "     Starting at: $NIC_NST"
# echo "      Ends    at: $NIC_NED"

cat > /tmp/dhcpd.conf <<EOF!
#
# DHCP Server Configuration file.
#   see /usr/share/doc/dhcp*/dhcpd.conf.sample
#   see 'man 5 dhcpd.conf'
#

allow booting;
allow bootp;
ddns-update-style interim;

## GOAL: service PXE BOOTP requests only
##   normal router will service everything else
group {
	# No fixed IP's here (not needed!)
	#  (you need to change these to match your systems OR use these)
	host pxe-client-1 { hardware ethernet 08:00:27:c1:b3:57; }
	host pxe-client-2 { hardware ethernet 08:00:27:c1:b3:58; }
	host pxe-client-3 { hardware ethernet 08:00:27:c1:b3:59; }
	host pxe-client-4 { hardware ethernet 08:00:27:c1:b3:5a; }

	# We'll use IP from this pool
	subnet ${NIC_NET} netmask ${NIC_MASK} {
		option vendor-class-identifier "PXEClient";
		filename "pxelinux.0";
		next-server ${NIC_ADDR};
		range ${NIC_RNG} ${NIC_NED};
		default-lease-time 1800;
		max-lease-time 4800;
		option routers ${NIC_RTR};
		option domain-name-servers ${NIC_RTR};
		option subnet-mask ${NIC_MASK};
		option domain-name "YOUR.DNS.DOMAIN.org";
		option time-offset -5;
		option ntp-servers ${NIC_RTR};
		option netbios-name-servers ${NIC_RTR};
	}
}

# END
EOF!

if diff /tmp/dhcpd.conf /etc/dhcp/dhcpd.conf > /dev/null 2>&1
then
  echo 'OK   [ check: /tmp/dhcpd.conf ] - no change so not installed'
else
  if [ $( wc -l /etc/dhcp/dhcpd.conf | awk '{print $1}' ) -gt 10 ]
  then
    echo 'OK   [ check: /tmp/dhcpd.conf ] - existing config not overwritten'
    echo "                                 :     ( install manually as needed ) "
  else
    [ -f /tmp/dhcpd.conf ] && cat /tmp/dhcpd.conf > /etc/dhcp/dhcpd.conf && \
    /bin/rm -f /tmp/dhcpd.conf
    [ $? -eq 0 ] && ST='OK  ' || ST=FAIL
    echo "$ST [ check: /tmp/dhcpd.conf ]"
  fi
  service dhcpd restart
fi

if [ -f /etc/centos-release -o -f /etc/redhat-release ]
then
  ST=OK

  echo -n "  Starting DHCP server           : "
  /sbin/chkconfig dhcpd on >> /tmp/dhcpd-install.log 2>&1
  [ $? -eq 0 ] && ST='OK  ' || ST=FAIL
  echo "$ST [ check: /tmp/dhcpd-install.log ]"
  /sbin/service dhcpd restart
fi

echo ''
echo ' TODO:'
echo '  1) Inspect the dhcpd.conf file and change as needed to'
echo '     meet the needs of your local network such as MAC addresses'
echo '  2) Inspect the tftpboot directory!'
echo '  3) PXE boot a system and enjoy the results.'
echo ''

# END
