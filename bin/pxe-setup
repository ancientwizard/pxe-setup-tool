#!/bin/bash

##
##  Introduction:
##    My preferred SHELL is ksh, as we have had a long and illustrious
##    career together; however I have used BASH here to keep things
##    simpler for this automation "demonstration" project.
##
##     I.E. show my scripting skills using a shell that should be
##          on any Linux system in existence by default.
##
##    If I were writing an application I would use Perl OR Java.
##    This however is an OS service setup automation and BASH
##      will suit us well.
##

##
##  TESTED ON:
##     CentOS 6.4 minimal server; expected to work on 3.x - 6.x
##            including RedHat
##     Ubuntu 12.04 desktop/server; fully expect it to work on
##            the 10.04 or earlier releases.
##     Debian 7 minimal server; wget https broken, added curl
##            as fallback on wget fail.
##     OpenSUSE 13.1; expected to work with 11.X and above
##
##  NOTES:
##         This script is not comprehensive or production ready. It
##         makes too many assumptions and provides no options or
##         flexibility for alternative solutions. It simply shows
##         one simple way to build a PXE boot server quickly.
##
##  ASSUMPTIONS:
##   1) The system to be PXE enabled is networked (kind of the point)
##   2) The system this script is run on is not doing something importent
##       (we will break any exising dhcp & tftp servers on the system,
##        the script assumes it has control)
##   3) The PXE system has Internet access to allow package installation
##   4) has standard DHCP services from a local router
##      [ home OR office etc ] ( we don't need fixed IP's for this,
##        and we only want to handle PXE DHCP requests if we can )
##   5) Other system(s)/VM(s) with PXE client enabled NIC's are available
##      (we need the server and at least one client to demo)
##

## Define few Functions

isNicUP()
{
  /sbin/ifconfig ${1-eth0} > /dev/null 2>&1
  return $?
}

getNicIP()
{
  echo $( /sbin/ifconfig ${1-eth0}|grep 'inet '|awk '{print $2}'|sed 's/^addr://' )
}

getNicBcst()
{
  BCST=$( /sbin/ifconfig ${1-eth0}|grep 'inet addr:'|awk '{print $3}'|awk -F: '{print $2}' )

  BCST=$( /sbin/ifconfig ${1-eth0}|grep 'inet ' | \
    sed 's/netmask /netmask:/g' | \
    sed 's/broadcast /broadcast:/g' | \
    awk '{print $4}'|awk -F: '{print $2}' )

  echo $BCST
}

getNicMask()
{
  MASK=$( /sbin/ifconfig ${1-eth0}|grep 'inet addr:'|awk '{print $4}'|awk -F: '{print $2}' )

  MASK=$( /sbin/ifconfig ${1-eth0}|grep 'inet ' | \
    sed 's/netmask /netmask:/g' | \
    sed 's/broadcast /broadcast:/g' | \
    awk '{print $3}'|awk -F: '{print $2}' )

  echo $MASK
}

isNicIPed()
{
  IP=$(getNicIP ${1-eth0})
  [ '' != "$IP" ]
  return $?
}

hasNicConfig()
{
  if [ -f /etc/centos-release -o -f /etc/redhat-release ]
  then
    [ -d /etc/sysconfig/network-scripts/ -a -e /etc/sysconfig/network-scripts/ifcfg-$1 ]
    return $?
  fi

  if [ -f /etc/lsb-release -a -f /etc/network/interfaces ]
  then
    #-- YUCK! - not reliable
    # grep -q "$NIC" /etc/network/interfaces

    #-- config may be "unseen" OR "subtle"
    #-- (bad: assume, if it's up life is good)
    isNicUP $1 && isNicIPed $1 && return $?
  fi

  return $?
}

isNicEnabled()
{
  [ -d /etc/sysconfig/network-scripts/ -a -e /etc/sysconfig/network-scripts/ifcfg-$1 ] && \
  grep -i '^ONBOOT=yes'   /etc/sysconfig/network-scripts/ifcfg-$1 > /dev/null 2>&1 ||
  grep -i '^ONBOOT="yes"' /etc/sysconfig/network-scripts/ifcfg-$1 > /dev/null 2>&1 && return $?

  [ -d /etc/sysconfig/network/ -a /etc/sysconfig/network/ifcfg-$1 ] && \
  grep -i "^STARTMODE='auto'" /etc/sysconfig/network/ifcfg-$1 > /dev/null 2>&1 && return $?

  return $?
}

enableNic()
{
  #-- RH, CentOS or Fedora etc
  [ -d /etc/sysconfig/network-scripts/ -a -e /etc/sysconfig/network-scripts/ifcfg-$1 ] && \
  {
    cat /etc/sysconfig/network-scripts/ifcfg-$1 | \
    sed 's/ONBOOT=no/ONBOOT=yes/' | sed 's/ONBOOT="no"/ONBOOT="yes"' > /tmp/ifcfg-$1
    cat /tmp/ifcfg-$1 > /etc/sysconfig/network-scripts/ifcfg-$1
    rm -f /tmp/ifcfg-$1
  }

  return $?
}

TurnUpNIC()
{
  #-- Selected NIC
  NIC=${1-eth0}

  hasNicConfig $NIC || return $?
  isNicEnabled $NIC || enableNic $NIC
  isNicUP      $NIC && isNicIPed $NIC && \
  {
    showMessage "Networking Status $NIC"
    showStatus $?
    return $?
  }

  ifup $NIC > /dev/null 2>&1
}

showMessage() { printf "  %-32s : " "$1"; }
showStatus()
{
  STA=$1 # Status
  NOT=$2 # Note

  [ $STA -eq  0 ] && ST=OK || ST=FAIL
  [ $STA -eq -1 ] && { ST=WARN; STA=1; }
  [ '' == "$NOT" ] && echo $ST
  [ '' == "$NOT" ] || printf "%-4s [ %s ]\n" $ST "$NOT"

  return $STA
}

processAction()
{
  MSG=$1
  CMD=$2
  LOG=$3

  STATUS=0
  
  showMessage "$MSG"
  $CMD >> ${LOG}.$$ 2>&1
  STATUS=$?
  showStatus $STATUS "check: ${LOG}.$$"

  return $STATUS
}


##
## Announce our title & locate a package installer
##

echo
echo '  PXE Environment Setup Tool'
echo '   ( an automation demonstration script )'
echo

showMessage 'Pruned Logs from Prior runs'
/bin/rm -f /tmp/pxe-*.log.[0-9]*
showStatus 0 || exit $?

INSTALLER=

[ -x /usr/bin/yum     ] && INSTALLER='/usr/bin/yum     --assumeyes  install'
[ -x /usr/bin/apt-get ] && INSTALLER='/usr/bin/apt-get --assume-yes install'
[ -x /usr/bin/zypper  ] && INSTALLER='/usr/bin/zypper  --non-interactive install'

[ '' == "$INSTALLER" ] && iFound=1 || iFound=0

showMessage 'Locate package installer'
showStatus $iFound "$INSTALLER" || exit $?


##
##  The Steps we (AKA: YOU) need to take to bring PXE booting to life.
##
##   1) Build a system/VM using a Linux Distro that this
##      script supports; you must do this yourself and download
##      this script to it. (I used CentOS "minimal-server")
##
##   2) My NIC was configured but not enabled to be turned on
##      at boot. I suspect a hold-over from a desktop setup where
##      some service allows the user to control it. All very ugly.
##      Lets make sure we're connected to the network or there is
##      little else we can do!
##


#-- First NIC UP wins!

NICX='eth0 eth1 eth2 eth3'
NICS=$( cd /proc/sys/net/ipv4/conf; ls -d * | egrep -v 'all|default|lo' )
[ '' == "$NICS" ] && NICS="$NICX"

for NIC in ${NICS}
do
  TurnUpNIC $NIC && break
done


##
##   3) Install the xinetd and tftpd services and get them up and running
##

#-- Install tftpd and dependencies
# RH/CentOS/Fedora == tftp-server
# Ubuntu           == tftpd
# openSUSE         == tftp yast2-tftp-server
msg='Installing TFTPD & XINETD Svcs'
pkg='tftpd'
[ -f /etc/centos-release -o -f /etc/redhat-release ] && pkg='tftp-server'
[ -f /etc/SuSE-release                             ] && pkg='tftp yast2-tftp-server'
log=/tmp/pxe-tftpd-service.log

processAction "$msg" "$INSTALLER $pkg" $log || exit $?


#-- Provide a /etc/xinetd.d/tftp
##  (if not included in package YUCK!)
if [ -d /etc/xinetd.d -a ! -f /etc/xinetd.d/tftp ]
then
  showMessage 'Install /etc/xinetd.d/tftp'
  cat > /etc/xinetd.d/tftp <<!TFTP
# Installed by $0
service tftp
{
	protocol        = udp
	port            = 69
	socket_type     = dgram
	wait            = yes
	user            = nobody
	server          = /usr/sbin/in.tftpd
	server_args     = -s /var/lib/tftpboot
	disable         = no
}

# END
!TFTP

  [ -f /etc/xinetd.d/tftp ] && chmod 0644 /etc/xinetd.d/tftp

  showStatus $? || exit $?
else
  showMessage 'Install /etc/xinetd.d/tftp'
  showStatus 0 'Preexists' || exit $?
fi


#-- Build empty /var/lib/tftpboot
##  (if not included in package YUCK!)
if [ -d /var/lib/tftpboot ]
then
  showMessage 'Create /var/lib/tftpboot'
  showStatus 0 'Preexists' || exit $?
else
  CMD=/tmp/pxe-create-tftpboot-dir.bash
  LOG=/tmp/pxe-create-tftpboot-dir.log
  cat > $CMD <<!MKDIR
#!/bin/bash
    mkdir -p     /var/lib/tftpboot
    chmod 0755   /var/lib/tftpboot
    chown nobody /var/lib/tftpboot
    [ -x /sbin/yast2 ] && chown tftp:tftp /var/lib/tftpboot
!MKDIR
  chmod 0755 $CMD
  processAction 'Create /var/lib/tftpboot' $CMD $LOG || exit $?
fi


#-- Symlink /srv/tftpboot (where needed)
if [ -d /srv/tftpboot -a ! -h /srv/tftpboot ]
then
  rmdir /srv/tftpboot > /dev/null 2>&1
fi

if [ -d /srv -a -d /var/lib/tftpboot -a ! -e /srv/tftpboot ]
then
  log=/tmp/pxe-symlink-tftpboot.log
  processAction "Symlink /srv/tftpboot" 'ln -s /var/lib/tftpboot /srv/' $log || exit $?
fi


#-- Enable tftpd
msg='Enabling TFTPD'
log=/tmp/pxe-tftpd-service.log

if [ -x /sbin/yast2 ]
then
  processAction "$msg (enab)" '/sbin/yast2 tftp-server status enable' $log || exit $?
  processAction "$msg (show)" '/sbin/yast2 tftp-server status show' $log || exit $?
  processAction "$msg (path)" '/sbin/yast2 tftp-server directory path=/var/lib/tftpboot' $log || exit $?
  processAction "$msg (list)" '/sbin/yast2 tftp-server directory list' $log || exit $?
elif [ -x /sbin/chkconfig ]; then
  processAction "$msg" "/sbin/chkconfig tftp on" $log || exit $?
else
  showMessage "$msg"
  showStatus 0 'Assumed' || exit $?
fi


#-- Restart xinetd
# default   == xinetd
# Debian    == openbsd-inetd
pkg=xinetd
msg='Start/Restart XINETD'
log=/tmp/pxe-inetd-service.log
[ -f /etc/os-release -a $( grep -ic debian /etc/os-release ) -gt 0 ] && pkg='openbsd-inetd'


if [ -x /usr/bin/systemctl ]
then
  processAction "$msg (start)"  "systemctl start  $pkg" $log || exit $?
  processAction "$msg (enable)" "systemctl enable $pkg" $log || exit $?
  processAction "$msg (status)" "systemctl status $pkg" $log || exit $?
else
  processAction "$msg"          "service $pkg restart" $log || exit $?
  processAction '$msg (status)' "service $pkg status"  $log || exit $?
fi

#-- Configure firewall
if [ -f /etc/os-release -a $( grep -ic opensuse /etc/os-release ) -gt 0 ]
then
  #-- (openSUSE)
  log=/tmp/pxe-firewall.log
  for svc in 'service:dhcp-server' 'service:tftp'
  do
    processAction "Firewall $svc" "/sbin/yast2 firewall services add service=$svc zone=EXT" $log || exit $?
  done

elif [ -f /etc/centos-release -o -f /etc/redhat-release ]; then
  #-- (CentOS & RH)
  msg='Add iptables rule for tftpd'
  showMessage "$msg"
  /sbin/iptables --list --line-numbers | grep -q tftp || \
  /sbin/iptables --insert INPUT 5 -m state --state NEW --proto udp --dport 69 -j ACCEPT > \
      /tmp/pxe-iptables.log.$$ 2>&1
  showStatus 0 "check: /tmp/pxe-iptables.log.$$" || exit $?

  msg='Save iptabels rules'
  showMessage "$msg"
  /sbin/iptables-save > /etc/sysconfig/iptables 2>> /tmp/iptables.log.$$
  showStatus 0 "check: /tmp/pxe-iptables.log.$$" || exit $?
fi


##
##   4) Install syslinux; it includes the binaries to build PXE boot-chains
##      And populate tftpboot with these binaries and our example menus
##

#-- Install syslinux and dependencies
# RH/CentOS == syslinux
# Ubuntu    == syslinux
msg='Installing SYSLINUX software'
pkg='syslinux'
log=/tmp/pxe-syslinux-install.log

processAction "$msg" "$INSTALLER $pkg" $log || exit $?


#-- Prepare the /var/lib/tftpboot/ dir for usage
##   (populate it!)

(
  TFTPBOOTTGT=/var/lib/tftpboot
  [ -d $TFTPBOOTTGT ] || { echo 'Failed to find tftpboot dir'; exit 1; }

  cd $TFTPBOOTTGT || exit 1

  showMessage 'Populating tftpboot PXE menus'
  (
    cat <<!EOF
help/help.txt
help/version.txt
pxelinux.cfg/default
pxelinux.cfg/default.jpg
pxelinux.cfg/cent-os
pxelinux.cfg/cent-os.jpg
pxelinux.cfg/open-suse
pxelinux.cfg/open-suse.jpg
pxelinux.cfg/red-hat
pxelinux.cfg/red-hat.jpg
pxelinux.cfg/tools
pxelinux.cfg/tools.jpg
pxelinux.cfg/ubuntu
pxelinux.cfg/ubuntu.jpg
pxelinux.cfg/windows
pxelinux.cfg/windows.jpg
images/floppy-dos.imz
images/floppy-grub.imz
images/memtest86+-5.01.iso.gz
!EOF
  ) | \
  while read item
  do
    DIR=$( dirname $item )
    FIL=$( basename $item )
    [ -d $DIR ] || mkdir -p $DIR
    (
      cd $DIR || exit 1
      [ -f $FIL ] || \
      wget https://raw.githubusercontent.com/ancientwizard/pxe-setup-tool/master/tftpboot/${item} || \
      curl https://raw.githubusercontent.com/ancientwizard/pxe-setup-tool/master/tftpboot/${item} > $FIL
    )
  done > /tmp/pxe-populate-tftpboot.log.$$ 2>&1

  showStatus $? "check: /tmp/pxe-populate-tftpboot.log.$$" || exit $?


  cd $TFTPBOOTTGT || exit 1
  ST=0
  showMessage 'Populating tftpboot binaries'
  (
    [ -f pxelinux.0   ] || { ln $( echo /usr/*/syslinux/pxelinux.0   ) || ST=1; }
    [ -d bin ] || mkdir bin
    cd bin || ST=1
    [ -f menu.c32     ] || { ln $( echo /usr/*/syslinux/menu.c32     ) || ST=1; }
    [ -f vesamenu.c32 ] || { ln $( echo /usr/*/syslinux/vesamenu.c32 ) || ST=1; }
    [ -f memdisk      ] || { ln $( echo /usr/*/syslinux/memdisk      ) || ST=1; }
  ) >> /tmp/pxe-populate-tftpboot.log.$$ 2>&1
  showStatus $ST  "check: /tmp/pxe-populate-tftpboot.log.$$"
)


##
##   6) Install, configure and start the DHCP service
##      We need this to tell the PXE booting system what to do
##      (I.E. here is you IP sir, go and get this file ... )
##
##   BUGS: I assume the subnet is at least a class "C" in size!
##         (anything smaller and the computed range may be wrong)
##

#-- Install dhcpd and dependencies
# RH/CentOS == dhcp
# Ubuntu    == dhcp3-server
msg='Installing DHCPD server'
pkg='dhcp3-server'
log=/tmp/pxe-dhcpd-service.log

[ -f /etc/centos-release -o -f /etc/redhat-release ] && pkg='dhcp'
[ -f /etc/os-release -a $( grep -ic opensuse /etc/os-release ) -gt 0 ] && pkg='yast2-dhcp-server dhcp-server'

processAction "$msg" "$INSTALLER $pkg" $log || exit $?

# iptables --verbose --insert INPUT 5 -m state --state NEW --proto udp --dport 67 -j ACCEPT
#  (i did not have to do this for DHCP, initial packets are bcast/discovery and make it through;
#   my best guess) - RH/CentOS


#-- Compute Network values from the "UP" NIC
##   use them to build a simple dhcpd.conf file.

showMessage 'Building dhcpd.conf file'

NIC_ADDR=$(getNicIP   $NIC)
NIC_MASK=$(getNicMask $NIC)
NIC_BCST=$(getNicBcst $NIC)

declare -a ADDR=( $(echo $NIC_ADDR|sed 's/[.]/ /g') )
declare -a MASK=( $(echo $NIC_MASK|sed 's/[.]/ /g') )
declare -a BCST=( $(echo $NIC_BCST|sed 's/[.]/ /g') )

NIC_NET="$(( ${ADDR[0]} & ${MASK[0]} )).$(( ${ADDR[1]} & ${MASK[1]} ))"
NIC_NET="${NIC_NET}.$(( ${ADDR[2]} & ${MASK[2]} ))"
NIC_NET="${NIC_NET}.$(( ${ADDR[3]} & ${MASK[3]} ))"

NIC_NST="$(( ${ADDR[0]} & ${MASK[0]} )).$(( ${ADDR[1]} & ${MASK[1]} ))"
NIC_NST="${NIC_NST}.$(( ${ADDR[2]} & ${MASK[2]} ))"
NIC_NST="${NIC_NST}.$(( ( ${ADDR[3]} & ${MASK[3]} ) + 1 ))"

NIC_NED="${BCST[0]}.${BCST[1]}.${BCST[2]}.$(( ${BCST[3]} - 1 ))"

NIC_RNG="${BCST[0]}.${BCST[1]}.${BCST[2]}.240"

NIC_RTR=$( netstat -rn|grep $NIC|grep '^0.0.0.0'|awk '{print $2}' )

cat > /tmp/dhcpd.conf <<!EOF
#
# DHCP Server Configuration file.
#   see /usr/share/doc/dhcp*/dhcpd.conf.sample
#   see 'man 5 dhcpd.conf'
#

allow booting;
allow bootp;

option domain-name "YOUR.DNS.DOMAIN.org";
option domain-name-servers ${NIC_RTR};
option routers ${NIC_RTR};
option ntp-servers ${NIC_RTR};
option netbios-name-servers ${NIC_RTR};

default-lease-time 1800;

ddns-update-style interim;

## GOAL: service PXE BOOTP requests only
##   normal router will service everything else

group {
# match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";

  # No fixed IP's here (not needed!)
  #  (you need to change these to match your systems OR use these)
  host pxe-client-1 { hardware ethernet 08:00:27:c1:b3:57; }
  host pxe-client-2 { hardware ethernet 08:00:27:c1:b3:58; }
  host pxe-client-3 { hardware ethernet 08:00:27:c1:b3:59; }
  host pxe-client-4 { hardware ethernet 08:00:27:c1:b3:5a; }

  # We'll use IP from this pool
  subnet ${NIC_NET} netmask ${NIC_MASK} {
    option vendor-class-identifier "PXEClient";
    filename "pxelinux.0";
    next-server ${NIC_ADDR};
    range ${NIC_RNG} ${NIC_NED};
    max-lease-time 4800;
    option routers ${NIC_RTR};
    option subnet-mask ${NIC_MASK};
    option time-offset -5;
  }
}

# END
!EOF

DHCPDCONF=/etc/dhcp/dhcpd.conf
[ -f /etc/dhcpd.conf ] && DHCPDCONF=/etc/dhcpd.conf

if diff /tmp/dhcpd.conf $DHCPDCONF > /dev/null 2>&1
then
  showStatus 0 'check: /tmp/dhcpd.conf - no change, not installed'
else
  if [ $( grep -v '^#' $DHCPDCONF | grep -v '^$' | awk '{print $1}' | wc -l ) -gt 10 ]
  then
    showStatus 0 'check: /tmp/dhcpd.conf - existing config not overwritten'
    showMessage ''
    echo "      ( install manually as needed )"
  else
    [ -f /tmp/dhcpd.conf ] && cat /tmp/dhcpd.conf > $DHCPDCONF && \
    /bin/rm -f /tmp/dhcpd.conf
    showStatus $? "check: $DHCPDCONF and /tmp/dhcpd.conf"
  fi
fi


#-- Enable DHCPD
msg='Enabling DHCP server'
log=/tmp/pxe-dhcpd-service.log

if [ -x /sbin/yast2 ]
then
  processAction "$msg (intr)" "/sbin/yast2 dhcp-server interface select=$NIC" $log || exit $?
  processAction "$msg (enab)" '/sbin/yast2 dhcp-server enable' $log || exit $?
#-- Always fails even though it works - some kind of bug
# processAction "$msg (curr)" "/sbin/yast2 dhcp-server interface current" $log || exit $?
# processAction "$msg (stat)" '/sbin/yast2 dhcp-server status' $log || exit $?
elif [ -x /sbin/chkconfig ]; then
  processAction "$msg" '/sbin/chkconfig dhcpd on' $log || exit $?
else
  showMessage "$msg"
  showStatus 0 'Assumed' || exit $?
fi


#-- Start/Restart DHCP server

msg='Start/Restart DHCP'
pkg=isc-dhcp-server
log=/tmp/pxe-dhcpd-service.log

[ -f /etc/centos-release -o -f /etc/redhat-release ] && pkg=dhcpd
[ -f /etc/os-release -a $( grep -ic opensuse /etc/os-release ) -gt 0 ] && pkg='dhcpd'

if [ -x /usr/bin/systemctl ]
then
  processAction "$msg (enable)" "systemctl disable $pkg" $log || exit $?
  processAction "$msg (enable)" "systemctl enable  $pkg" $log || exit $?
  processAction "$msg (start)"  "systemctl start   $pkg" $log || exit $?
  processAction "$msg (status)" "systemctl status  $pkg" $log || exit $?
else
  processAction "$msg" "service $pkg restart" $log || exit $?
fi


echo ''
echo ' TODO:'
echo '  1) Inspect the dhcpd.conf file and change as needed to'
echo '     meet the needs of your local network such as MAC addresses'
echo '  2) Inspect the tftpboot directory!'
echo '  3) PXE boot a system and enjoy the results.'
echo '  4) ON Fedora you may need to enable tftpd yourself.'
echo '     see: /etc/xinetd.d/tftp'
echo ''

# END
